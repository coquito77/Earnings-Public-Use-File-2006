---
title: "Tufte Handout"
author: "John Smith"
date: "August 13th, 2014"
output:
  tufte::tufte_handout:
    fig_width: 10
    fig_height: 10
---

```{r options, cache = FALSE, echo=FALSE, include=FALSE}

# set global chunk optionsrm(list=ls(all=TRUE)) #start with empty workspace
rm(list=ls(all=TRUE)) #start with empty workspace

startTime <- Sys.time()

knitr::opts_chunk$set(cache = TRUE, echo = FALSE, include = FALSE)

doInstall <- FALSE # Change to TRUE if you do want packages installed.
toInstall <- c( "data.table", "tidyr", "dplyr", "ggplot2",
                "scales","RColorBrewer", "ineq", "showtext",
                "stringr", "grid")

if (doInstall) {install.packages(toInstall, repos = "http://cran.us.r-project.org")}
lapply(toInstall, library, character.only = TRUE)

setwd("~/GitHub/Earnings-Public-Use-File-2006/") # set the working directory
list.files() # see whats there

#packrat::off()

```

```{r importData, eval=FALSE}

# this if to replicate this study
# https://www.newyorkfed.org/medialibrary/media/research/staff_reports/sr710.pdf

temp <- tempfile()

download.file("https://www.socialsecurity.gov/policy/docs/microdata/epuf/epuf2006_csv_files.zip",
               quiet = TRUE, 
              destfile = temp)

con <- unzip(temp)

# take a look at the files on the data
con

ptm <- proc.time()
  
dataAnnual <- fread(con[1], 
                    header = T,
                    verbose = FALSE,
                    sep = ',',
                    showProgress = TRUE)

proc.time() - ptm

dataDemographics <- fread(con[2], header = T, sep = ',')%>%
  select( -c(TOT_COV_EARN3750, QC3750, QC5152))

### download CPI data

# https://research.stlouisfed.org/fred2/series/CPIAUCSL/downloaddata
# or here
# http://download.bls.gov/pub/time.series/cw/cw.data.0.Current

# to calculate real wages
# import the data and extract the index for each year in January

# http://www.cpwr.com/sites/default/files/annex_how_to_calculate_the_real_wages.pdf

wagesCPI <- fread("./CPIAUCSL.csv") %>%
  mutate(Year = substr(DATE, 1, 4) ) %>%
  group_by(Year) %>%
  slice(1)

```

```{r getUniqueSample, eval = FALSE}

# to get a sample 
# 1. expand the earnings to the max years reported
# 2. join the expanded earnings with the demographics
# 2. get a sample by age starting 20 years old, then at 30, 40, 50, 60
# by year, by gender

EarningsSummarizedByYear <- dataAnnual %>%
  select(ID, YEAR_EARN) %>%
  mutate(YEAR_EARN = as.integer(YEAR_EARN)) %>%
  group_by(ID) %>%
  mutate(minYear = min(YEAR_EARN),
         maxYear = max(YEAR_EARN)) %>%
  select(ID,minYear, maxYear) %>%
  distinct() %>%
  mutate(Years = maxYear - minYear) %>%
  select(ID, minYear, Years)

# take a look at the summirized data

hist(EarningsSummarizedByYear$Years)

boxplot(EarningsSummarizedByYear$Years)

boxplot(EarningsSummarizedByYear$Years, plot = FALSE)

# exclude records that have less than 9 years earnings

EarningsSummarizedByYear <- EarningsSummarizedByYear %>%
  filter(Years > 9)

# expand the data and merge it with the orig data

dataAnnualSampleSetLong <- EarningsSummarizedByYear[,.(Year=minYear+0:(Years-1)), ID] %>%
  mutate(YEAR_EARN = as.character(Year)) %>%
  select(-Year) %>%
  left_join(dataAnnual) %>%
  group_by(ID) %>%
  arrange(YEAR_EARN)

rm(EarningsSummarizedByYear)
gc()

# merge with the demographics data and calc age
# select records that have earings when age is 20 years (before or after ok)
# get the min for each ID
# merge with the expanded earnings set

IDbyFirstYear <- dataAnnual %>% 
  select(ID, YEAR_EARN) %>%
  left_join(dataDemographics) %>%
  select(ID, YEAR_EARN, YOB, SEX) %>%
  mutate(YOB = as.integer(YOB),
         YearEarn = as.integer(YEAR_EARN),
         AgeEarnings = YearEarn - YOB) %>%
  arrange(ID, YEAR_EARN) %>%
  filter(AgeEarnings == 20) %>%
  group_by(ID) %>%
  slice(1)

length((unique(IDbyFirstYear$ID)))

with(IDbyFirstYear, table(YEAR_EARN, SEX, useNA = "ifany" ))

# get a sample of 4000 unique ID by year and gender

set.seed(1)

sampleRecordsFemaleStart20Yrs <- IDbyFirstYear %>%
  filter(SEX == 2) %>%
  group_by(YEAR_EARN) %>%
  do(sample_n(., 4000, replace = FALSE)) %>%
  select(ID) 

with(sampleRecordsFemaleStart20Yrs, table(YEAR_EARN, useNA = "ifany" ))

sampleRecordsMaleStart20Yrs <- IDbyFirstYear %>%
  filter(SEX == 1) %>%
  group_by(YEAR_EARN) %>%
  do(sample_n(., 4000, replace = FALSE)) %>%
  select(ID) %>%
  full_join(sampleRecordsFemaleStart20Yrs) %>%
  select(-YEAR_EARN)

sampleRecordsMaleAndFemaleWithEArningsAt20Yrs <- sampleRecordsMaleStart20Yrs %>%
  inner_join(dataAnnualSampleSetLong) %>%
  left_join(dataDemographics) %>%
  mutate(YOB = as.integer(YOB),
         YearEarn = as.integer(YEAR_EARN),
         AgeEarnings = YearEarn - YOB) %>%
  filter(AgeEarnings > 19)

rm(list=setdiff(ls(),
                c("sampleRecordsMaleAndFemaleWithEArningsAt20Yrs",
                  "wagesCPI",
                  "startTime")))

gc()

# calculate real wages

# http://www.cpwr.com/sites/default/files/annex_how_to_calculate_the_real_wages.pdf

setEveryFithYear <- sampleRecordsMaleAndFemaleWithEArningsAt20Yrs %>%
  group_by(ID) %>% 
  slice(c( seq(1, 60, by=5 ))) %>% # get the earnings
  left_join(wagesCPI,
            by = c("YEAR_EARN" = "Year")) %>%
  select(-DATE) %>%
  mutate(ANNUAL_EARNINGS = as.integer(ANNUAL_EARNINGS),
         realWage = (ANNUAL_EARNINGS / VALUE)*100)

rm(list=setdiff(ls(),
                c("setEveryFithYear",
                  "startTime")))

gc()

summary(setEveryFithYear)

str(setEveryFithYear)

# save.image("./lifeCyclErnnRiskRData.RData")

# remove the SSA data

unlink("./EPUF2006_ANNUAL.csv")

unlink("./EPUF2006_DEMOGRAPHIC.csv")
```


```{r loadData, echo= FALSE}

load("lifeCyclErnnRiskRData.RData")

```

```{r plotHistogramOfScores, eval=FALSE, fig.cap = "Most people make around the same amount of money five years later", message = FALSE, warning = FALSE, include=TRUE}

# http://stackoverflow.com/questions/5688082/ggplot2-overlay-histogram-with-density-curve

colourCount = length(unique(setEveryFithYear$AgeEarnings))
getPalette = colorRampPalette(brewer.pal(8, "Accent"))

setEveryFithYear %>%
  ggplot( aes(realWage, color = as.factor(AgeEarnings))) +
  geom_freqpoly(aes(), bins = 100, alpha = 1/3, position="identity") +
  stat_function(fun = dnorm, 
                na.rm = TRUE,
                args = list(mean = mean(setEveryFithYear$realWage, 
                                        na.rm = TRUE), 
                            sd = sd(setEveryFithYear$realWage,
                                    na.rm = TRUE)), 
                #lwd = 1, 
                size = 1,
                alpha = 1/3,
                col = 'red') +
  scale_y_continuous(#trans=log_trans(), 
    labels = comma) +
  scale_x_continuous(labels = comma) +
  theme_minimal() +
  scale_color_manual(values = getPalette(colourCount),
                     name = "Earnings by year") +
  labs(x = "Earnings", y = "Frequency")

```


```{r plotHistogramOfScoresByYear, eval=FALSE, fig.cap = "Most people make around the same amount of money five years later", message = FALSE, warning = FALSE, include=TRUE}

# http://stackoverflow.com/questions/5688082/ggplot2-overlay-histogram-with-density-curve

setEveryFithYear %>%
  ggplot( aes(realWage, fill = as.factor(AgeEarnings))) +
  geom_histogram(aes(), bins = 100, alpha = 1/3, position="identity") +
  facet_wrap(~ YOB, ncol = 7) +
  stat_function(fun = dnorm, 
                na.rm = TRUE,
                args = list(mean = mean(setEveryFithYear$realWage, 
                                        na.rm = TRUE), 
                            sd = sd(setEveryFithYear$realWage,
                                    na.rm = TRUE)), 
                #lwd = 1, 
                size = 1,
                alpha = 1/3,
                col = 'red') +
  scale_fill_manual(values = getPalette(colourCount),
                     name = "Earnings by year") +
  scale_y_continuous(labels=function(x)x/1000)+
  scale_x_continuous(labels = comma) +
  #coord_cartesian(xlim = c(30000, 30000)) +
  theme_minimal() +
  labs(x = "Earnings by year", y = "Frequency (thousands)") +
  theme(
    #panel.grid.major = element_blank(), 
    #panel.grid.minor = element_blank(),
    panel.background = element_rect(colour = "grey90",
                                    size = 1),
    strip.text.x = element_text(size = 4, 
                                colour = "black", 
                                angle = 00 #, lineheight = .5
    ),
    axis.title.x = element_text(size = 8, 
                                angle = 00),
    axis.text.x = element_text(colour = "black", 
                               size = 4, 
                               angle = 90, 
                               vjust = .5),
    axis.title.y = element_text(size = 8, 
                                angle = 90),
    axis.text.y = element_text(colour = "black", 
                               size = 5, 
                               angle = 00, 
                               vjust = .5),
    plot.margin = unit(c(0,0,0,0), "cm"))



setEveryFithYear %>%
  ggplot( aes(realWage, color = as.factor(AgeEarnings))) +
  geom_freqpoly(aes(), bins = 100, alpha = 1/3, position="identity") +
  facet_wrap(~ YOB, ncol = 10) +
  stat_function(fun = dnorm, 
                na.rm = TRUE,
                args = list(mean = mean(setEveryFithYear$realWage, 
                                        na.rm = TRUE), 
                            sd = sd(setEveryFithYear$realWage,
                                    na.rm = TRUE)), 
                #lwd = 1, 
                size = 1,
                alpha = 1/3,
                col = 'red') +
  scale_colour_manual(values = getPalette(colourCount),
                     name = "Earnings by year") +
  scale_y_continuous(labels=function(x)x/1000)+
  scale_x_continuous(labels = comma) +
  #coord_cartesian(xlim = c(30000, 30000)) +
  theme_minimal() +
  labs(x = "Earnings by year", y = "Frequency (thousands)") +
  theme(
    #panel.grid.major = element_blank(), 
    #panel.grid.minor = element_blank(),
    panel.background = element_rect(colour = "grey90",
                                    size = 1),
    strip.text.x = element_text(size = 4, 
                                colour = "black", 
                                angle = 00 #, lineheight = .5
    ),
    axis.title.x = element_text(size = 8, 
                                angle = 00),
    axis.text.x = element_text(colour = "black", 
                               size = 4, 
                               angle = 90, 
                               vjust = .5),
    axis.title.y = element_text(size = 8, 
                                angle = 90),
    axis.text.y = element_text(colour = "black", 
                               size = 5, 
                               angle = 00, 
                               vjust = .5),
    plot.margin = unit(c(0,0,0,0), "cm"))

```


```{r setSpreadCalcRealWage}

setEveryFithYearByAgeEarnings <- setEveryFithYear %>%
  mutate(AgeEarningsGroup = paste0("AgeEarnings", AgeEarnings)) %>%
  select( ID,  YOB, SEX, AgeEarningsGroup, realWage) %>%
  spread( AgeEarningsGroup, realWage) %>%
  ungroup %>%
  mutate( RankAgeEarnings20 =  ntile(AgeEarnings20, 100))

percentChange <- setEveryFithYearByAgeEarnings %>%
  group_by(ID ) %>%
  mutate_each(funs(whatever = (. - AgeEarnings20)/AgeEarnings20), AgeEarnings25:AgeEarnings70) %>%
  gather(AgeEarnings, PercentChange, -c(ID, YOB, SEX, AgeEarnings20, RankAgeEarnings20))

```





```{r plotPercentChange, eval= FALSE}
d <- percentChange %>%
  mutate(AgeEarningsNum =  substr(AgeEarnings, 12,13) ,
         AgeEarningsNum = as.numeric(AgeEarningsNum)) %>%
 ggplot( aes(AgeEarningsNum, PercentChange)) + geom_point()

d + stat_summary(fun.y = "median", colour = "red", size = 2, geom = "point")

d + aes(colour = factor(RankAgeEarnings20)) + stat_summary(fun.y = median, geom="line")

d

```

```{r statSummary, eval=TRUE, fig.fullwidth = TRUE, fig.cap = "Percent Wage Increase By Earnings Percentile at 20 years old", message = FALSE, warning = FALSE, include=TRUE}

library(e1071)
library(psych)

setPercentChange <- percentChange %>% 
  select(AgeEarnings, RankAgeEarnings20, PercentChange) %>%
  ungroup() %>%
  mutate(PercentChange = as.numeric(PercentChange*100)) %>%
  na.omit() %>% as.data.frame %>%
  select(AgeEarnings, RankAgeEarnings20, PercentChange)

setSummaryPercentChange <- setPercentChange %>%
  group_by(AgeEarnings, RankAgeEarnings20) %>% 
  summarise(count = n(),
            mean = mean(PercentChange),
            sd = sd(PercentChange),
            skew = psych::skew(PercentChange),
            median = median(PercentChange),
            kurtosis = e1071::kurtosis(PercentChange))

SamplesetSummaryPercentChange <- setSummaryPercentChange %>%
  mutate(AgeEarningsNum =  substr(AgeEarnings, 12,13) ,
         AgeEarningsNum = as.numeric(AgeEarningsNum))  %>% 
  filter(RankAgeEarnings20 %in% (c(1:5,53:48,96:100)))
  
  # display.brewer.all()

colourCount = length(unique(SamplesetSummaryPercentChange$RankAgeEarnings20))
getPalette = colorRampPalette(brewer.pal(8, "Set1"))

ggplot(SamplesetSummaryPercentChange,
       aes(AgeEarnings, median, group = RankAgeEarnings20, color = as.factor(RankAgeEarnings20) )) +
  geom_line(alpha = 1/2 ) +
  scale_y_continuous(trans = log_trans(), 
    labels = comma) +
  theme_minimal() +
  scale_color_manual(values = getPalette(colourCount),
                     name = "Earnings rakings at 20 years old") +
  theme(
    #panel.grid.major = element_blank(), 
    #panel.grid.minor = element_blank(),
    axis.title.x = element_text(size = 8, 
                                angle = 00),
    axis.text.x = element_text(colour = "black", 
                               size = 4, 
                               angle = 90, 
                               vjust = .5),
    axis.title.y = element_text(size = 8, 
                                angle = 90),
    axis.text.y = element_text(colour = "black", 
                               size = 5, 
                               angle = 00, 
                               vjust = .5)#,
    #plot.margin = unit(c(0,0,0,0), "cm")
  )

```


```{r GiniCoeficient, eval = TRUE}

# inspiration is from here
# http://ellisp.github.io/blog/2015/09/12/inequality-stats-distributions/

setEveryFithYear <- setEveryFithYear %>% 
  mutate(YOEarnedRounded = signif(YearEarn, 3))

doPlot = function(sel_name) {
  dum = filter(setEveryFithYear, YOEarnedRounded == sel_name) %>% droplevels()
  
  Gini(dum$realWage, corr = FALSE, na.rm = TRUE)
}

test <- lapply(unique(setEveryFithYear$YOEarnedRounded), doPlot)

Category_names <- unique(setEveryFithYear$YOEarnedRounded)
# assign player names to list of tables
names(test) <- Category_names

df <- test %>% # head(1000) %>%
  plyr::ldply(data.frame) %>%
  select(Category = 1, GiniValue = 2) %>%
  arrange(Category)

df 

```


```{r table survivalFinalpander, include=TRUE}

library(pander)

#panderOptions('digits', 2)
panderOptions('round', 2)
panderOptions('keep.trailing.zeros', TRUE)
panderOptions('decimal.mark', ".")
panderOptions('big.mark', ",")
panderOptions('table.split.cells', c(5, 3, 5, 5, 3, 5))

pander(df,
       split.table = Inf,
       caption = "Real wages Gini coefiencient by decade. The higher the coeficient the more unequal are the earnings.  A coeficient of zero all individuals have the same income")

```

```{r plotLorezCurve, eval=TRUE, fig.fullwidth = TRUE, fig.cap = "Percent Wage Increase By Earkings Percentile at  20 years old", message = FALSE, warning = FALSE, include=TRUE}

doPlot = function(sel_name) {
  dum = filter(setEveryFithYear, YOEarnedRounded == sel_name) %>% droplevels()
  
  lorenz <- Lc(dum$realWage)
  
  lorenz_df <- data.frame(prop_pop = lorenz$p, income = lorenz$L) %>%
    mutate(prop_equality = prop_pop)
  
}

test <- lapply(unique(setEveryFithYear$YOEarnedRounded), doPlot)

Category_names <- unique(setEveryFithYear$YOEarnedRounded)
# assign player names to list of tables
names(test) <- Category_names

df <- test %>% # head(1000) %>%
  plyr::ldply(data.frame) %>%
  select(ethnicity = 1, prop_pop, income, prop_equality)

p1 <- ggplot(df, aes(x = prop_pop, y = income)) +
  geom_ribbon(aes(ymax = prop_equality, ymin = income), fill = "yellow") +
  geom_line() +
  facet_wrap(~ ethnicity,  ncol = 1) +
  geom_abline(slope = 1, intercept = 0) +
  scale_x_continuous("\nCumulative proportion of population", label = percent) +
  scale_y_continuous("Cumulative proportion of income\n", label = percent) +
  theme_minimal(base_family = "Courier") +
  coord_equal() +
  annotate("text", 0.53, 0.32, label = "Inequality\ngap", family = "Courier") +
  annotate("text", 0.5, 0.6, label = "Complete equality line", angle = 45, family = "Courier") + 
  ggtitle (
    str_wrap("Cumulative distribution of real wages", 46))

print(p1)

grid.text("Source: SSAâ€™s Master Earnings File\n2006 Earnings Public-Use File", 0.8, 0.23, 
          gp = gpar(fontfamily = "Courier", fontsize = 8))


```

```{r plot, eval = FALSE}


makeplot_mosaic <- function(data, x, y, ...){
  xvar <- deparse(substitute(x))
  yvar <- deparse(substitute(y))
  mydata <- data[c(xvar, yvar)];
  mytable <- table(mydata);
  widths <- c(0, cumsum(apply(mytable, 1, sum)));
  heights <- apply(mytable, 1, function(x){c(0, cumsum(x/sum(x)))});

  alldata <- data.frame();
  allnames <- data.frame();
  for(i in 1:nrow(mytable)){
    for(j in 1:ncol(mytable)){
      alldata <- rbind(alldata, c(widths[i], widths[i+1], heights[j, i], heights[j+1, i]));
    }
  }
  colnames(alldata) <- c("xmin", "xmax", "ymin", "ymax")

  alldata[[xvar]] <- rep(dimnames(mytable)[[1]],rep(ncol(mytable), nrow(mytable)));
  alldata[[yvar]] <- rep(dimnames(mytable)[[2]],nrow(mytable));

  ggplot(alldata, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax)) + 
    geom_rect(color="black", aes_string(fill=yvar)) +
    xlab(paste(xvar, "(count)")) + ylab(paste(yvar, "(proportion)"));
}

makeplot_mosaic(demographicWithSample,  SEX, FiveYearPrcnChngRankGroups)


```





```{r createDeciles, eval=FALSE}

demographicWithSampleTest <- demographicWithSample %>%
  mutate(YOB = as.numeric(YOB),
         AgeEarnings = Year-YOB) %>%
 group_by(YEAR_EARN, AgeEarnings) %>%
  mutate(AnnualRank =  ntile(ANNUAL_EARNINGS, 10),
         FiveYearRank =  ntile(fivePriorYearEarnings, 10),
         YOBrRounded = signif(YOB, 3)) %>%
  droplevels()



library(corrplot)

dataCorrelation <- demographicWithSample %>%
  ungroup() %>%
  mutate(YOB = as.numeric(YOB),
         AnnualRank =  ntile(ANNUAL_EARNINGS, 10),
         FiveYearRank =  ntile(fivePriorYearEarnings, 10),
         YOBrRounded = signif(YOB, 3)) %>%
group_by(YOBrRounded) %>%
summarize(cor(AnnualRank, FiveYearRank, use = "pairwise.complete.obs"))


ggplot(demographicWithSampleTest, aes(AnnualRank, FiveYearRank)) +
  geom_jitter(alpha = 1/10) + stat_smooth() +
  geom_smooth(method = "lm", se = FALSE, color = "red") + 
  #geom_abline(color = "green") +
  facet_wrap(~YOBrRounded)


 ggtitle(paste("Correlation = ",round(cor(demographicWithSampleTest$AnnualRank,demographicWithSampleTest$FiveYearRank),digits=2),sep="")) + 
   
   
```

# Introduction
First, starting with the first moment, we find that average earnings growth over the
life cycle varies strongly with the level of lifetime earnings: the median individual by
lifetime earnings experiences an earnings growth of 38% from ages 25 to 55, whereas for
individuals in the 95th percentile, this figure is 230%; for those in the 99th percentile,
this figure is almost 1500%.3

```{r TODO, eval = FALSE}

# add transition chart or slope chart
# https://cran.r-project.org/web/packages/Gmisc/vignettes/transitionPlot.html
# http://stackoverflow.com/questions/26393793/in-r-how-do-you-make-transition-charts-with-the-gmisc-package

rm(list=ls(all=TRUE)) #start with empty workspace

# https://github.com/jkeirstead/r-slopegraph/blob/master/slopegraph.r


##' @title R script for creating slopegraphs
##' @author James Keirstead
##' 12 December 2013
##' http://www.jameskeirstead.ca/r/slopegraphs-in-r/ 

##' Build a slopegraph data set
##'
##' Modifies a data frame so that it can be used for plotting by
##' \code{plot_slopegraph}.  The general structure of a slopegraph is
##' \itemize{
##' \item a factor giving the group labels
##' \item an ordered factor giving the x intervals
##' \item a numeric giving the y values
##' }
##' 
##' @param df the raw data frame
##' @param x a character giving the name of the x-axis column.  This
##' column must be an ordered factor.
##' @param y a character giving the name of the y-axis column.  This
##' column must be a numeric.
##' @param group a character giving the name of the group column.
##' This column must be a factor.
##' @param method a character string indicating which method to use to
##' calculate the position of elements.  Values include "tufte"
##' (default), "spaced", "rank", "none".
##' @param min.space fraction of total data range to leave as a
##' minimum gap (default = 0.05, only used by methods \code{spaced}
##' and \code{tufte})
##' @details The \code{method} option allows the y-position of the
##' elements to be calculated using different assumptions.  These are:
##' \itemize{ \item \code{tufte} Values in the first x-column are
##' sorted based on their numeric value.  Subsequent group lines are
##' then shifted to ensure that the lines for two adjacent groups
##' never cross.  Vertical positions in subsequent columns are only
##' meaningful relative to the first entry in that group.  \item
##' \code{spaced} The vertical position of each element is chosen to
##' ensure a minimum spacing between all elements and preserving the
##' rank order within columns.  Group lines can cross.  \item
##' \code{rank} The vertical position of each element represents its
##' rank within the column.  \item \code{none} The vertical position
##' of each element is based solely on its value }
##' @return a data frame with labelled columns, group, x, y, and ypos
build_slopegraph <- function(df, x, y, group, method="tufte", min.space=0.05) {

    ## First rename the columns for consistency
    ids <- match(c(x, y, group), names(df))
    df <- df[,ids]
    names(df) <- c("x", "y", "group")

    ## Expand grid to ensure every combination has a defined value
    tmp <- expand.grid(x=unique(df$x), group=unique(df$group))
    tmp <- merge(df, tmp, all.y=TRUE)
    df <- mutate(tmp, y=ifelse(is.na(y), 0, y))

    ## Then select and apply the appropriate method
    if (method=="spaced") {
        df <- spaced_sort(df, min.space=min.space)
        return(df)
    } else if (method=="none") {
        df <- mutate(df, ypos=y)               
        return(df)
    } else if (method=="rank") {
        df <- ddply(df, .(x), summarize, x=x, y=y, group=group, ypos=rank(y))
        return(df)
    } else if (method=="tufte") {
        df <- tufte_sort(df, min.space=min.space)
        return(df)
    } else {
        template <- "Method '%s' currently unsupported."
        warning(sprintf(template, method))
    }
}

##' Spaced sort for slopegraphs
##'
##' Calculates the position of each element to ensure a minimum
##' space between adjacent entries within a column, while preserving
##' rank order.  Group lines can cross
##' @param df the raw data frame
##' @param min.space fraction of total data range to leave as a
##' minimum gap
##' @return a data frame with the ypos column added
spaced_sort <- function(df, min.space=0.05) {
    ## Define a minimum spacing (5% of full data range)
    min.space <- min.space*diff(range(df$y))

    ## Transform the data
    df <- ddply(df, .(x), calc_spaced_offset, min.space)
    return(df)
}

##' Calculates the vertical offset between successive data points
##' 
##' @param df a data frame representing a single year of data
##' @param min.space the minimum spacing between y values
##' @return a data frame
calc_spaced_offset <- function(df, min.space) {

    ## Sort by value
    ord <- order(df$y, decreasing=T)
    ## Calculate the difference between adjacent values
    delta <- -1*diff(df$y[ord])
    ## Adjust to ensure that minimum space requirement is met 
    offset <- (min.space - delta)
    offset <- replace(offset, offset<0, 0)
    ## Add a trailing zero for the lowest value
    offset <- c(offset, 0)
    ## Calculate the offset needed to be added to each point
    ## as a cumulative sum of previous values
    offset <- rev(cumsum(rev(offset)))
    ## Assemble and return the new data frame
    df.new <- data.frame(group=df$group[ord],
                         x=df$x[ord],
                         y=df$y[ord],
                         ypos=offset+df$y[ord])
  return(df.new)
}


##' Calculates slope graph positions based on Edward Tufte's layout
##'
##' @param df the raw data frame with named x, y, and group columns
##' @param min.space fraction of total data range to leave as a
##' minimum gap
##' @return a data frame with an additional calculate ypos column
tufte_sort <- function(df, min.space=0.05) {

    ## Cast into a matrix shape and arrange by first column
    require(reshape2)
    tmp <- dcast(df, group ~ x, value.var="y")
    ord <- order(tmp[,2])
    tmp <- tmp[ord,]
    
    min.space <- min.space*diff(range(tmp[,-1]))
    yshift <- numeric(nrow(tmp))
    ## Start at "bottom" row
    ## Repeat for rest of the rows until you hit the top
    for (i in 2:nrow(tmp)) {
        ## Shift subsequent row up by equal space so gap between
        ## two entries is >= minimum
        mat <- as.matrix(tmp[(i-1):i, -1])
        d.min <- min(diff(mat))
        yshift[i] <- ifelse(d.min < min.space, min.space - d.min, 0)
    }

    
    tmp <- cbind(tmp, yshift=cumsum(yshift))

    scale <- 1
    tmp <- melt(tmp, id=c("group", "yshift"), variable.name="x", value.name="y")
    ## Store these gaps in a separate variable so that they can be scaled ypos = a*yshift + y

    tmp <- transform(tmp, ypos=y + scale*yshift)
    return(tmp)
   
}


##' A theme for plotting slopegraphs
##'
##' @param base_size a numeric giving the base font size
##' @param base_family a string giving the base font family
##' @import grid
theme_slopegraph <- function (base_size = 12, base_family = "") {
    require(grid)
    theme(axis.line = element_blank(),
          axis.text = element_text(colour="black"),
          axis.text.x = element_text(size = rel(1), lineheight = 0.9,
              vjust = 1),
          axis.text.y = element_text(size=rel(0.8)),
          axis.ticks = element_blank(),
          axis.title.x = element_blank(),
          axis.title.y = element_blank(),
          axis.ticks.length = unit(0, "lines"),
          axis.ticks.margin = unit(0, "lines"), 
          panel.background = element_blank(),
          panel.border = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.margin = unit(0.25, "lines"), 
          strip.background = element_blank(),
          strip.text.x = element_text(size = rel(0.8)),
          strip.text.y = element_blank(),
          plot.background = element_blank(),
          plot.title = element_text(size = rel(1)),
          plot.margin = unit(c(1, 0.5, 0.5, 0.5), "lines"),
          complete=FALSE)
}


##' Plots a slopegraph
##'
##' @param df a data frame giving the data
##' @return a ggplot object
##' @import ggplot2
plot_slopegraph <- function(df) {
    ylabs <- subset(df, x==head(x,1))$group
    yvals <- subset(df, x==head(x,1))$ypos
    fontSize <- 2.5
    gg <- ggplot(df,aes(x=x,y=ypos)) +
        geom_line(aes(group=group),colour="grey80") +
        geom_point(colour="white",size=8) +
        geom_text(aes(label=y),size=fontSize) +
        scale_y_continuous(name="", breaks=yvals, labels=ylabs)
    gg.form <- gg + theme_slopegraph()
    return(gg.form)
}


library(data.table)
 data  <- fread("https://raw.githubusercontent.com/jkeirstead/r-slopegraph/master/cancer_survival_rates.csv", 
                    header = T,
                    verbose = FALSE,
                    sep = ',',
                    showProgress = TRUE)
    
library(ggplot2)

##' Convert raw data to right format
df <- build_slopegraph(data, x="year", y="value", group="group", method="tufte", min.space=0.05)

## Refactor the x-axis to get the right labels, round the y values for presentation
df <- transform(df, x=factor(x, levels=c(5,10,15,20),
                        labels=c("5 years", "10 years", "15 years", "20 years")),
                y=round(y))
##' Generate the raw plot
gg.form <- plot_slopegraph(df) +
    labs(title="Estimates of % survival rates") 

##' Save the results
w <- 6  	# width in inches
h <- 1.6*w	# height in inches
ggsave("slopegraph.pdf",gg.form,w=w,h=h)
dpi <- 150  	# resolution for png
ggsave("slopegraph.png",gg.form,w=w,h=h,dpi=dpi)




